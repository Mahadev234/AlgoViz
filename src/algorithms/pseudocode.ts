export const sortingPseudocode = {
  bubble: [
    "procedure bubbleSort(A: list of sortable items)",
    "    n = length(A)",
    "    for i from 0 to n-1 do",
    "        for j from 0 to n-i-1 do",
    "            if A[j] > A[j+1] then",
    "                swap(A[j], A[j+1])",
    "            end if",
    "        end for",
    "    end for",
    "end procedure"
  ],
  selection: [
    "procedure selectionSort(A: list of sortable items)",
    "    n = length(A)",
    "    for i from 0 to n-1 do",
    "        minIndex = i",
    "        for j from i+1 to n do",
    "            if A[j] < A[minIndex] then",
    "                minIndex = j",
    "            end if",
    "        end for",
    "        swap(A[i], A[minIndex])",
    "    end for",
    "end procedure"
  ],
  insertion: [
    "procedure insertionSort(A: list of sortable items)",
    "    n = length(A)",
    "    for i from 1 to n-1 do",
    "        key = A[i]",
    "        j = i - 1",
    "        while j >= 0 and A[j] > key do",
    "            A[j+1] = A[j]",
    "            j = j - 1",
    "        end while",
    "        A[j+1] = key",
    "    end for",
    "end procedure"
  ],
  merge: [
    "procedure mergeSort(A: list of sortable items)",
    "    if length(A) <= 1 then",
    "        return A",
    "    end if",
    "    mid = length(A) / 2",
    "    left = mergeSort(A[0..mid-1])",
    "    right = mergeSort(A[mid..end])",
    "    return merge(left, right)",
    "end procedure",
    "",
    "procedure merge(left, right)",
    "    result = []",
    "    while length(left) > 0 and length(right) > 0 do",
    "        if left[0] <= right[0] then",
    "            append left[0] to result",
    "            left = left[1..end]",
    "        else",
    "            append right[0] to result",
    "            right = right[1..end]",
    "        end if",
    "    end while",
    "    append remaining elements of left to result",
    "    append remaining elements of right to result",
    "    return result",
    "end procedure"
  ],
  quick: [
    "procedure quickSort(A: list of sortable items, low, high)",
    "    if low < high then",
    "        pivotIndex = partition(A, low, high)",
    "        quickSort(A, low, pivotIndex - 1)",
    "        quickSort(A, pivotIndex + 1, high)",
    "    end if",
    "end procedure",
    "",
    "procedure partition(A, low, high)",
    "    pivot = A[high]",
    "    i = low - 1",
    "    for j from low to high-1 do",
    "        if A[j] <= pivot then",
    "            i = i + 1",
    "            swap(A[i], A[j])",
    "        end if",
    "    end for",
    "    swap(A[i+1], A[high])",
    "    return i + 1",
    "end procedure"
  ]
}; 